import numpy as np

def bisection(fun, xl, xu, err_max=1e-5, iter_max=1000):
    """ 
 Inputs:       fun:      callable function       Function dependent on x to be searched
               xl:       scalar                  Lower bound
               xu:       scalar                  Upper bound
               err_max:  scalar                  Acceptable relative approximation error, epsilon_s
               iter_max: scalar                  Acceptable number of iterations
  
 Output:       root:     scalar                  Value of x where function equals zero
               err_est   scalar                  Value of relative error approximation, epsilon_a
               numIter   scalar                  The number of iterations used
               exitFlag  scalar                  1 if algorithm terminates properly
                                                 0 if max iteration value is reached
                                                 -1 if invalid brackets given
                                                 -2 if function ever returns with NaN or infinity
   
 NOTE: This function requires that the signs of the endpoints be opposite.
    i.e., np.sign(fun(xl)) must not equal np.sign(fun(xu))
    """
    # Check inputs first
    if not callable(fun): #callable() is a method that returns the True value if the object passed appears to be callable, 
    #and if not then returns False. 
        raise Exception('The first input must be a callable function.') #to throw an exception if a condition occurs
    
    if not isinstance(xl, float) and not isinstance(xl, int): #returns whether an object is an instance of a class
        #making sure that the input is either a real number or an integer number
        raise Exception('The second and third inputs must be scalar values.')
    
    if not isinstance(xu, float) and not isinstance(xu, int):
        raise Exception('The second and third inputs must be scalar values.')
    
    if (not isinstance(err_max, float) and not isinstance(err_max, int)) or err_max <=0:
        raise Exception('The fourth and fifth inputs must be positive scalar values.')
    
    if (not isinstance(iter_max, float) and not isinstance(iter_max, int)) or iter_max <=0:
        raise Exception('The fourth and fifth inputs must be positive scalar values.')
        
    if xl >= xu:
        raise Exception('The lower bound (second input) must be less than the upper bound (third input).')
    
    # initialize        
    done = False
    numIter = 0
    root = np.nan
    err_est = np.nan
    
    # check the endpoints
    fl = fun(xl)
    fu = fun(xu)
    
    if fl*fu > 0: # this will happen if signs are the same #or can use fun(xl)*fun(xu) < 0
        done = True
        exitFlag = -1   #-1 if invalid brackets given
    
    elif fl*fu == 0: # this will happen if one of the endpoints is a root
        done = True
        err_est = 0    
        if abs(fl) <= abs(fu):
            root = xl
        else:
            root = xu    
    
    # Main Code
    while not done: #while the variable done is NOT equal True, to keep the While loop running until done = True 
        numIter += 1
        
        # Bisect the endpoints
        xc = (xu + xl) / 2  #xc = xr, the center point in this method, just the name we choose
        fc = fun(xc)
        
        if np.isnan(fl) or np.isnan(fu) or np.isnan(fc):
            exitFlag = -2   #-2 if function ever returns with NaN or infinity
            break
        
        if np.isinf(fl) or np.isinf(fu) or np.isinf(fc):
            exitFlag = -2
            break
        
        if fl*fc == 0: # this will happen if one of the points is actually a root
            done = True
            exitFlag = 1 # 1 if algorithm terminates properly
            err_est = 0 
            root = xc
            break
        
        elif fl*fc > 0: # this will happen if signs are the same
            xl = xc # replace the end with the like-signed value
        else:
            xu = xc
        
        err_est = 100*abs((xu-xl)/(xc))
        
        if err_est <= err_max: # stop if we're close enough
            done = True
            root = xc
            exitFlag = 1
            break
        
        if numIter >= iter_max: # check for infinite loop
            done = True
            exitFlag = 0
            root = xc # closest guess
            break # this break isn't really necessary since it is the last part of the loop
        
    return root, err_est, numIter, exitFlag
